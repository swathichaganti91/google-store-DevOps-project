name: CI/CD Full Stack Google Store
on:
  push:
    branches:
      - main

env:
  AWS_REGION: ap-northeast-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.ap-northeast-1.amazonaws.com
  SERVICES: "frontend backend electronics phones computers earphones"
  K8S_NAMESPACE: default
  CLUSTER_NAME: abinash

permissions:
  contents: write
  id-token: write  # Required for OIDC

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      # 1. Checkout the repository
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Configure AWS Credentials via OIDC (Recommended & Secure)
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsEKSFullAccessRole
          role-session-name: github-eks-session
          aws-region: ${{ env.AWS_REGION }}

      # 3. Debug AWS Identity (Verify Role Assumption)
      - name: Verify AWS Identity
        run: |
          echo "Assumed Role:"
          aws sts get-caller-identity

      # 4. Login to Amazon ECR
      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      # 5. Build, tag, and push Docker images
      - name: Build, tag, and push Docker images
        run: |
          for service in $SERVICES; do
            if [ -d "$service" ]; then
              echo "Processing $service..."
              IMAGE_TAG="${{ github.sha }}"
              REPO_NAME="google-store-$service"
             
              # Create ECR repo if not exists
              aws ecr describe-repositories --repository-names $REPO_NAME >/dev/null 2>&1 || \
                aws ecr create-repository --repository-name $REPO_NAME
              
              IMAGE_URI="$ECR_REGISTRY/$REPO_NAME:$IMAGE_TAG"
              
              # Build & push
              docker build -t $IMAGE_URI ./$service
              docker push $IMAGE_URI
              
              # Update deployment.yml
              if [ -f $service/deployment.yml ]; then
                sed -i "s|image:.*|image: $IMAGE_URI|g" $service/deployment.yml
              fi
            else
              echo "Skipping $service, folder not found."
            fi
          done

      # 6. Commit updated deployment files
      - name: Commit updated deployment files
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'
          git add */deployment.yml
          git commit -m "Update image tags in deployment files [skip ci]" || echo "No changes"
          git push || echo "Nothing to push"

      # 7. Connect to EKS with Role ARN (CRITICAL FIX)
      - name: Connect to EKS cluster
        run: |
          echo "Updating kubeconfig with role assumption..."
          aws eks update-kubeconfig \
            --name ${{ env.CLUSTER_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --role-arn arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsEKSFullAccessRole \
            --alias github-actions

          echo "Switching context..."
          kubectl config use-context github-actions

          echo "Testing cluster access..."
          kubectl get nodes

      # 8. Apply Kubernetes manifests
      - name: Apply Kubernetes manifests
        run: |
          for service in $SERVICES; do
            if [ -d "$service" ]; then
              [ -f $service/service.yml ] && kubectl apply -f $service/service.yml
              [ -f $service/deployment.yml ] && kubectl apply -f $service/deployment.yml
              [ -f $service/autoscaler.yml ] && kubectl apply -f $service/autoscaler.yml
            fi
          done
          [ -f deployment.yml ] && kubectl apply -f deployment.yml
          [ -f service.yml ] && kubectl apply -f service.yml
          [ -f ingress.yml ] && kubectl apply -f ingress.yml --validate=false

      # 9. Verify deployment
      - name: Verify resources
        run: |
          echo "Pods:"
          kubectl get pods -n ${{ env.K8S_NAMESPACE }}
          echo "Services:"
          kubectl get svc -n ${{ env.K8S_NAMESPACE }}
          echo "Ingress:"
          kubectl get ingress -n ${{ env.K8S_NAMESPACE }}
